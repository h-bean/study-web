# HTTP

## 모든 것이 HTTP

- HTTP (HyperTest Transfer Protocol)  
  원래 : HTML등을 링크로 연결하기 위해 만들어 졌음  
  지금 : 모든것을 HTTP 메시지로 전송
  - HTML, TEXT
  - IMAGE, 음성, 영상, 파일
  - JSON, XML(API)
  - 거의 모든 형태의 데이터 전송 가능
  - 서버간 데이터 주고 방을 때도 대부분 HTTP사용 (HTTP시대다!)

- HTTP 역사
  - HTTP/1.1 가장 중요

- 기반 프로토콜
  - HTTP/1.1, HTTP/2 -> TCP 프로토콜 위에서 동작
  - HTTP/3 -> UDP 기반


## 클라이언트 서버 구조

- 클라이언트는 서버에 요청(Request)을 보내고, 응답 대기  
  서버가 요청에 대한 결과를 만들어 응답 (Response)
  
- 클라이언트는 UI등 처리
- 비즈니스 로직과 데이터는 서버에서 처리  
  -> 서로 독립적인 진화가 가능


## Stateful, Stateless

- HTTP는 무상태 프로토콜 지향 (Stateless)
  - 서버가 클라이언트 상태를 보존X

- Stateful, Stateless 차이
  - 상태 유지 : 중간에 점원이 바뀌면 안됨  
    (바뀔 경우 일 처리 불가능)
  - 무상태 : 중간에 점원이 바뀌어도 OK
    - 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.  
      = 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
  - 무상태는 응답 서버를 쉽게 바꿀 수 있다 -> 무한한 서버 증설 가능 (스케일 아웃)
  
  - Stateless 는 확장성 측면에서 GOOD!
  - 무상태 이기 때문에 계속해서 자신의 상태를 서버에게 알려줘야 함
  - 서버는 클라이언트를 몰라도, 클라이언트가 상태정보를 주니까 쉽게 처리 가능
  - 점원이 계속 바뀌어도, 처리가 가능하다! (확장성)

- 무상태 장점  
  ![무상태](https://user-images.githubusercontent.com/98109708/151758049-47fd1e5a-b2b9-461e-9735-fe5143a0a13d.png)  
  - 요청 1, 2, 3 처리하다 2번 요청에 서버 장애나면 다른 서버가 응답 가능
  - Stateful이었다면..요청 1 부터 다시 해야함
  
- Stateless의 실무 한계
  - 단점1) 모든 것을 무상태로 할 수 없음 (ex. 로그인 상태유지 필요)  
      - 로그인 한 사용자는 로그인 했다는 "상태"를 서버에 유지
      - 일반적으로 브라우저 쿠키와 세션등을 사용해 상태 유지
      - 상태유지는 최소한만 사용하자
  
  - 담전2) 너무 많은 데이터를 매번 보내야 함 (서버에서 상태 유지 안하니까...)


## 비 연결성 (connectionless)

- 클라이언트 요청/응답 후 연결을 계속 유지한다면, 서버 자원이 낭비가 됨
- 요청/응답 후에 연결을 끊으면? 서버는 최소한의 자원을 사용

- HTTP는 기본이 연결을 유지하지 않는 모델!
  - 일반적으로 초 단위 이하의 빠른 속도로 응답
  - 서버 자원을 매우 효율적으로 사용할 수 있음
  
- HTTP의 비 연결성의 단점?
  - TCP/IP 연결을 새로 맺어야 함 (3 Way Handshake 시간 +)
  - 웹 브라우저로 사이트 요청하면 HTML뿐 아니라 JS, CSS, 이미지 등 수 많은 자원 함께 다운로드
  - 지금은 HTTP 지속연결(Persistent Connections)로 문제 해결  
    이전에는 연결 - 요청/html 응답 - 연결 끊기 / 연결 - 요청/js 응답 - 연결 끊기 했다면..  
    지금은 연결 - 요청/html 응답 - 요청/js 응답 - 연결 끊기
    한 페이지 받을 때 까지의 연결은 유지함

- 저녁 6시 선착순 치킨 할인 이벤트 같은 대용량 트래픽 발생 시 대처 방안?  
  최대한 stateless하게 설계하고, 서버 증설  
  + 맨 앞 페이지는 아무것도 없는 정적 페이지로 유입되게 하고 버튼 타고 들어와야 하는 식으로 처리


## HTTP 메시지
![http메시지](https://user-images.githubusercontent.com/98109708/151770194-7b0f7efe-6dcc-4baa-ac9a-d5bbe0a975df.png)

- 응답 메시지 / HTTP 상태 코드 중요
  - 200: 성공
  - 400: 클라이언트 요청 오류
  - 500: 서버 내부 오류

- 응답 메시지 / HTTP 헤더
  - 필요한 메타 데이터 정보 다 ~ 들어 있음
  - 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보,  
    서버 애플리케이션 정보, 캐시 관리 정보..