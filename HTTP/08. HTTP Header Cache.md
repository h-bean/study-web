# HTTP 헤더 : 캐시와 조건부 요청

## 캐시 기본 동작

- 캐시가 없다면
  - 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다.
  - 브라우저 로딩 속도가 느리다. (느린 사용자 경험)
  
- 캐시 적용  
  ![캐시](https://user-images.githubusercontent.com/98109708/151937400-f7f20ea1-f177-49b1-9f15-b8a523460a4e.png)
  - cache-control: max-age=60 // 60초 동안 유효하게 하겠다.
    - 두 번째 요청 부터는 브라우저 캐시 저장소에서 먼저 찾음
  - 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
  - 브라우저 로딩 속도가 매우 빠르다. (빠른 사용자 경험)

- 캐시 적용 - 캐시 시간 초과
  - 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다.
  - 이때 다시 네트워크 다운로드가 발생한다.

-> 요청한 내용이 달라지면 상관 없지만.. 동일한 경우 캐시 시간이 만료돼도  
  또 서버에 갔다오는건 비효율적!  
  이것을 처리하기 위한 메커니즘이 있다 ~
  

## 검증 헤더와 조건부 요청 1

- 캐시 유효시간이 초과해서 서버에 다시 요청하면, 아래 두 가지 상황이 발생  
  1.서버에서 기존 데이터를 변경함  
  2.서버에서 기존 데이터를 변경하지 않음 -> 해결 가능! (검증 헤더와 조건부 요청으로 ~)

- 캐시 만료후에도 서버에서 데이터를 변경하지 않음
  - 생각해보면 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용 할 수 있다.
  - 단 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요 ✔

- 검증 헤더 추가  
  ![검증헤더1](https://user-images.githubusercontent.com/98109708/151938455-70c2ccc2-95ff-4026-a6e3-3c533572b727.png)
  - 데이터의 최종 수정일을 함께 보낸다.
  - 캐시 저장소에 함께 저장됨!
  - 캐시 시간 초과 후, 재 요청 시...  
    ![검증헤더2](https://user-images.githubusercontent.com/98109708/151938598-040a425a-85c1-4b49-bdfd-0d5d09e3de8e.png)
    - 데이터 최종 수정일(검증헤더)이 있네?! 함께 싣어(조건부 요청) 서버에 요청 ✔
    - 서버에서 요청 받고, 데이터 최종 수정일이 같으면?
  - 304 Not Modified 내리고, Body부 없이 보냄!!!  
    ![검증헤더3](https://user-images.githubusercontent.com/98109708/151947429-354aa4af-e6b5-459b-8510-31b46b18c373.png)
    - 전송 용량이 확 줄어듦! 로컬에 들고있는 데이터 재사용 ~ good!

- 검증 헤더와 조건부 요청 정리
  - 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면
  - 304 Not Modified + 헤더 메타 정보만 응답(바디X)
  - 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
  - 클라이언트는 캐시에 저장되어 있는 데이터 재활용
  - 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드
  - 매우 실용적인 해결책

- 웹 브라우저들은 대부분 다 이 메커니즘을 알아서 실행하고 있다 ~


## 검증 헤더와 조건부 요청 2

- 검증 헤더
  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - Last-Modified , ETag

- 조건부 요청 헤더
  - 검증 헤더로 조건에 따른 분기
    - If-Modified-Since : Last-Modified 사용
    - If-None-Match : ETag 사용
  - 조건이 만족하면 200 OK
  - 조건이 만족하지 않으면 304 Not Modified

- 예시 (Last-Modified, If-Modified-Since)  
  : If-Modified-Since 이후에 데이터가 변경 되었으면?
  - 데이터 미변경 예시 (수정 X)
    - 캐시: 2020년 11월 10일 10:00:00 vs 서버: 2020년 11월 10일 10:00:00
    - 304 Not Modified, 헤더 데이터만 전송(BODY 미포함)
    - 전송 용량 0.1M (헤더 0.1M, 바디 1.0M)
  - 데이터 변경 예시 (수정 O)
    - 캐시: 2020년 11월 10일 10:00:00 vs 서버: 2020년 11월 10일 11:00:00
    - 200 OK, 모든 데이터 전송(BODY 포함)
    - 전송 용량 1.1M (헤더 0.1M, 바디 1.0M)

- Last-Modified, If-Modified-Since 단점
  - 1초 미만(0.x초) 단위로 캐시 조정이 불가능 (초단위다!)  
    하지만.. 0.1초단위까지 필요할까 싶음 ㅇ_ㅇ
  - 날짜 기반의 정해진 로직 사용  
    A->B 수정 했다가, B->A로 다시 수정해도 날짜는 변경 돼 있음  
    이런 경우에도 전체 데이터 다~ 다시 다운!
  - 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
  - 서버에서 별도의 캐시 로직을 관리하고 싶은 경우  
    ex. 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

--> 서버에서 완전히 캐시 메커니즘 컨트롤?! ETag 사용하면 가능하다 ~

- ETag(Entity Tag), If-None-Match
  - 캐시용 데이터에 임의의 고유한 버전을 달아줌  
    ex. ETag: "v1.0", ETag: "a2jiodwjekjl3"
  - 데이터가 변경되면 이 이름을 바꾸어서 변경 (Hash 재 생성)  
    ex. ETag: "aaaaa" -> ETag: "bbbbb"
  - 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기

- ETag 과정  
  ![etag1](https://user-images.githubusercontent.com/98109708/151949519-7124ee3b-3575-4b9b-8fba-5d2630b38dcd.png)
  ![etag2](https://user-images.githubusercontent.com/98109708/151949521-b97e7a60-8f4c-47a3-ae5b-3641e4984bac.png)

- ETag, If-None-Match 정리
  - 진짜 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기!
  - 캐시 제어 로직을 서버에서 완전히 관리
  - 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)
  - ex.
    - 서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지 (실제 이렇게까지는 않함)
    - 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신 (이건 함)


## 캐시와 조건부 요청 헤더

캐시 지시어(directives)  

- Cache-Control
  : 이게 중요! 이걸로 다 할수 있고, Paragma와 는 하위 호환을 위해 사용함
  - Cache-Control: max-age ✔  
    캐시 유효 시간, 초 단위  
  - Cache-Control: no-cache  
    데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용  
    중간에 있는 캐시 프록시 서버 말고, 진짜 응답해주는 서버에서만! 검증해라!!
  - Cache-Control: no-store  
    데이터에 민감한 정보가 있으므로 저장하면 안됨  
    (메모리에서 사용하고 최대한 빨리 삭제

- Paragma
  - 캐시 제어 (하위 호환)  
    ex. Pragma: no-cache

- Expires
  - 캐시 만료일 지정 (하휘 호환)  
    ex. expires: Mon, 01 Jan 1990 00:00:00 GMT

- 검증 헤더 (Validator)
  - ETag: "v1.0", ETag: "asid93jkrh2l"
  - ETag: "v1.0", ETag: "asid93jkrh2l
  
- 조건부 요청 헤더
  - If-Match, If-None-Match: ETag 값 사용
  - If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용


## 프록시 캐시

- 원 서버 (Origin 서버) 직접 접근 VS 프록시 캐시  
  ![프록시캐시](https://user-images.githubusercontent.com/98109708/151954594-7e710ec9-7b75-415e-9f0c-f116330762f7.png)
  - 원서버에 직접 접근할 경우 모든 클라이언트 요청이 0.5초 걸림!
  - 하지만 프록시 캐시 서버를 통해 접근하면? 캐시된것 뱉어주니까 더 빠른 응답 가능
  - 이런게 바로 CDN 서비스 !!!
  - 주로 외국 사이트에서 많이 이용됨 (ex. 유튜브)
  - 보통 최초 접근하는 client에게만 느리고 다음 client 요청 부터는 빠름


## 캐시 무효화

- 확실히 캐시를 못하게 하는 방법 (주요 데이터 있는 화면의 경우!!)
  - no-cache만 할 경우, 브라우저가 임의로 캐시 해버리기도 함..
  - Cache-Control: no-cache, no-store, must-revalidate  
    Pragma: no-cache  // 이건 하위 브라우저 있을 수 있으니 넣어주기  
    위에 캐시 지시어 다~ 넣어줘야 한다..!

- 캐시 지시어 (directives) : 확실한 캐시 무효화
  - Cache-Control: no-cache
    - 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용(이름에 주의!)
  - Cache-Control: no-store
    - 데이터에 민감한 정보가 있으므로 저장하면 안됨  
      (메모리에서 사용하고 최대한 빨리 삭제)
  - Cache-Control: must-revalidate 
    - 캐시 만료후 최초 조회시 원 서버에 검증해야함
    - 원 서버 접근 실패시 반드시 오류가 발생해야함 - 504(Gateway Timeout)
    - must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
  - Pragma: no-cache 
    - HTTP 1.0 하위 호환
    
